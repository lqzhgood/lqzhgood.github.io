---
title: 如果前端请求有1G
categories:
  - study
  - js
date: 2023-09-23 22:05:34
tags:
---


## 起因

最近在面试，聊到个人项目 [Shmily](http://lqzhgood.github.io/Shmily)，这个项目是将 QQ、微信、短信等各种数据汇总并时间线展示的一个项目，其中子项目 [Shmily-Show](https://github.com/lqzhgood/Shmily-Show) 一个难点就是纯前端处理大量的聊天记录（总计1.41G，最大单文件240M）。

面试官基于此引申出一个问题：__如果前端单一请求大小有1G,，可以和后端采取哪些方案加速？__ [Shmily](http://lqzhgood.github.io/Shmily) 是一个本地的 Web 应用，所以并不存在这个传输问题。生产中这是一个不合理的需求，应该从为什么有 1G 的角度去考虑。面试官也一再强调这只是假设情况，但不妨碍这是一个有趣的问题，就像刮刮乐还没刮开，就已经在想 500 万怎么花。


## 思考

当时只回答了`分块传输`、`Gzip` 和 `CDN`，后来细想这个问题可以从两方面回答
- 缩小体积
  - Gzip / Brotli 等压缩算法
  - 优化文件内容，如路径提取公共目录，使用时拼接
- 提高速度
  - 提高带宽
    - CDN
    - WebRTC P2P
  - 分块传输，和后端协商分割文件
    - `HTTP/1` 中 `Chrome` 单个`域`可以最大并行6个请求，可以通过 `DNS` 泛解析绕过限制
    - `HTTP/2` 支持多路复用，没有6个请求的限制

刚刚洗澡时闪念 `分块传输`：其实可以不用后端配合做特殊处理，使用 `HTTP协议` 的 `Range` 特性即可做到。

[Shmily-Show](https://github.com/lqzhgood/Shmily-Show) 开发时使用 `Head` 方法探测文件是否存在，当时使用 [webd](https://webd.cf/) 作为 `webServer`。但 [webd](https://webd.cf/) 不支持 `Head` ，和作者聊透了 `Head` 的实现， 但最后建议我通过在 `headers` 中添加 `{Range:'bytes=0-0'}` 的 `Get` ， 去模拟 `Head` 的行为，毕竟 `Head` 不是每个 `webServer` 都会实现。

> 这里吹一波  [webd](https://webd.cf/)， 是我测过性能最好的 micro WebServer 。

所以 `分块传输` 前端通过 `Http-header-Range` 就可以实现

```js
// 伪代码如下

function multiDown( url = '/1G', max = 6 ){
    const controller = new AbortController();

    const { isSupport, ContentLength } = await ajax.get(url,{
        responseType: 'stream',
        headers:{Range:'bytes=0-0'},
        signal: controller.signal
    }).then(({ response, data })=>{
        controller.abort();
        return { isSupport: data.length <= 1,  ContentLength: response.headers['Content-Length']};
    })

    let r;

    if (!isSupport) {
        r = [ ajax.get(url) ];
    }else{
        // n=100 m=6 ['0-16', '17-33', '34-50', '51-67', '68-83', '84-99']
        const cutRange = splitInteger(ContentLength, max);
        r = cutRange.map( r => ajax.get(url,headers:{Range:`bytes=${r}`}));
    }

    return Promise.all(r)
}


function splitInteger(n, m) {
    if (m <= 0) {
        return [];
    }

    const quotient = Math.floor(n / m); // 计算每份的整数部分
    const remainder = n % m; // 计算余数

    const result = [];
    let start = 0;
    let end = 0;

    for (let i = 0; i < m; i++) {
        end = start + quotient - 1;
        if (i < remainder) {
            end += 1; // 将余数分配给前面的若干份
        }
        result.push(`${start}-${end}`);
        start = end + 1;
    }

    return result;
}
```


这么一看不就是下载软件常用的多线程分段下载嘛，那么 __通过浏览器下载一个大文件，且使用分段下载提速__ 这个需求看起来也挺合理的呀。


## Flag

先建一个库 https://github.com/lqzhgood/axios-multi-down， 忙完了这阵就开写。