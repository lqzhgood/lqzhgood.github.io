---
title: 面试题-数组去重
categories:
  - study
  - web
tags: js
date: 2016-07-09 17:01:27
---

面试题之一是，**数组的去重，尽量有普适性**。回来花了3个小时才写完，应该可以适用大部分环境。

#### 适用范围

* 可以区分： *空字符、null、undefined*
* 迭代处理： 数组中的 数组或对象 相同的值

<!--more-->

#### 问题
* 数组中的 数组/对象 需要 **一一对应**；因为这完全是主观的需求，程序是无法判断需要去重的两个对象。
>例如  
>a = [1, 2, 3 , 4 , {x:1,y:3}, {x:1,y:5} ,9 ];
>b = [1, 2, {x:1,y:3} ];
>你是要让 B[2] 和 A[2] 还是 A[3] 对比去重，这完全是主观的因素，程序无法判断。
>
>可以在 B[2] 的  **前/后** 添加　*空对象*　来对齐需要比较的对象/数组；默认采用倒序对齐， B[2] -> A[3];
>
>对齐的含义是 对象的顺序， 非对象在数组中的位置。


* 是直接对实参进行的操作，如果需要保留原始数组，需要额外进行深拷贝。
> 涉及到迭代，所以如果在函数中内建深拷贝会多很多无关函数来判断运行深度。增加复杂度，而深拷贝又和本函数没有太多相关联，完全可以额外进行。
>
> 之前一直使用 JSON.parse(JSON.stringify(obj)) 的方式进行深拷贝，这次发现在特殊值时会有问题，
> 例如
> a = [null,undefined];
> JSON.parse(JSON.stringify(a)); // 
> 结果是 [null, null]

* 对象值的初步判断是采用简单粗暴的字符串判断
> 例如
> a = ["1_",null]; 
> b = [1,"_null"];
> 
> toStr 函数会将对象以 分隔符 (var fgf) 相连，转化为 字符串进行初步判断是否完全相等。
> 如果 var fgf = "-" ;
> str_a = "1- -null";
> str_b = "1- -null";
> 在这种极端情况下如果数组字符中包含 fgf 的值则可能会导致误判。 因此如果有这种情况应该修改 fgf 的值为唯一值。
>
> 对象中的 key 顺序无法确定，会导致初步的 toStr 函数无效，进入for in 的详细判断，可能会浪费性能。

* 隐约觉得还有 BUG。


#### 一点想法
猜测是否可以采用 **排序** + **转化为字符串** 的方式来减少维度和计算量
>例如
>
> a = [8,5,3] ==> a= [3,5,8]
> b = [5,7];
> 如果 b 在 A[i]处匹配到了，下一次仅需要从 i+1 开始。
>
>a = [1 , 2 , 3 ] ==>  a[-1-2-3];
>只需要在 A 所有数组 中查找删除 -key 的关键词进行删除即可。不需要操作整个数组，而只需要对字符串进行一次操作即可删除全部 key。在对象的判断上应该比较方便，因为对象没有顺序。




#### 逻辑

```javascript

        function fn(ar, br) {            
            for (var i = ar.length - 1; i >= 0; i--) {
                for (var j = br.length - 1; j >= 0; j--) {
                 if (相等的字符串、null、undefined、同指针的对象){
                     删除
                 }else if (ar br 都是对象){
                     if (同为数组或对象){
                         if (toStr检测两者字符串是否相等){
                            删除
                         }else if (如果都为数组){
                             fn() 递归
                         }else{
                             如果都为对象
                             dbObj() 递归
                         }
                     }
                 }            
                  

        function dbObj(obja, objb) {
            var keya = "";
            var keyb = "";
            for (keya in obja) {
                for (keyb in objb) {
                    if (对象的字符串、null、undefined、同指针的对象相等) {
                        删除
                    }
                    else if (都为对象) {
                        if (都为数组) {
                            fn();
                        }
                        else { 都为对象
                            dbObj(); 递归
                        }
                    }
                }
            }
        }

        function toStr(obj) {
            递归将所有值 加上 分隔符 一起拼接到 str;
            return str;
        }

        function isArray(obj) {
           判断是否为数组
        }

```



#### 源码及测试




```javascript
        var fgf = "_";
        // 分隔符
        function fn(ar, br) {
            //深拷贝，复制数组，防止影响源文件
            //            var ar = JSON.parse(JSON.stringify(a));
            //            var br = JSON.parse(JSON.stringify(b));
            //本例不适合在函数内深拷贝
            for (var i = ar.length - 1; i >= 0; i--) {
                for (var j = br.length - 1; j >= 0; j--) {
                    if (ar[i] === br[j]) {
                        //处理相等的字符串、null、undefined、同指针的对象
//                        if (ar[i] === null && br[j] === undefined) {
//                            continue;
//                        }
//                        if (ar[i] === undefined && br[j] === null) {
//                            continue;
//                        }
//                        if (typeof ar[i] != "object" && typeof br[j] != "object") {}
                        ar.splice(i, 1);
                        br.splice(j, 1);
                    }
                    else if (ar[i] != null && br[j] != null && typeof ar[i] == "object" && typeof br[j] == "object") {
                        //处理值相等的对象和数组
                        if (isArray(ar[i]) == isArray(br[j])) {
                            //判断是否同为数组或同为对象
                            if (toStr(ar[i]) == toStr(br[j])) {
                                //检测字符串是否相等
                                ar.splice(i, 1);
                                br.splice(j, 1);
                            }
                            else if (isArray(ar[i]) && isArray(br[j])) {
                                //都为数组的情况 递归处理
                                fn(ar[i], br[j]);
                            }
                            else {
                                //都为对象的情况
                                dbObj(ar[i], br[j]);
                            }
                        }
                    }
                }
            }
        }

        function dbObj(obja, objb) {
            var keya = "";
            var keyb = "";
            for (keya in obja) {
                for (keyb in objb) {
                    if (obja[keya] === objb[keyb]) {
                        delete obja[keya];
                        delete objb[keyb];
                    }
                    else if (typeof obja[keya] == "object" && typeof objb[keyb] == "object") {
                        if (isArray(obja[keya]) && isArray(objb[keyb])) {
                            fn(obja[keya], objb[keyb]);
                        }
                        else {
                            dbObj(obja[keya], objb[keyb]);
                        }
                    }
                }
            }
        }

        function toStr(obj) {
            var str = "";
            var k = "";
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    if (obj[k] === null) {
                        str = str + fgf + "null";
                    }
                    else if (obj[k] === undefined) {
                        str = str + fgf + "undefined";
                    }
                    else if (typeof obj[k] == "object") {
                        if (isArray(obj[k])) {
                            str = str + fgf + "[" + toStr(obj[k]) + "]";
                        }
                        str = str + fgf + "{" + toStr(obj[k]) + "}";
                    }
                    else {
                        str += (fgf + obj[k]);
                    }
                }
            }
            return str;
        }

        function isArray(obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
        //   *********************************** test ***********************
        //  **********对象*****************
        //        var oba = {
        //            x:1,
        //            y:2,
        //            c:[1,5,8],
        //            z : {
        //                u : "c",
        //                i : "t",
        //                p : {
        //                    a : 1,
        //                    b:2
        //                }
        //            }
        //        }
        //        var obb = {
        //            x:1,
        //            y:3,
        //            c:[1,15,5,8],
        //            z : {
        //                u : "c",
        //                i : "a",
        //                p : {
        //                    a : 1,
        //                    b: 3
        //                }
        //            }
        //        }          
        //        
        //       dbObj(oba,obb);
        // ************数组和对象混合*********************
        //        var arr = [1,{x:1,y:2}];
        //        var brr = [1,{x:1,y:3}];
        //        
        //        var arr = [1,4,[1,4,{x:1,y:3}]];
        //        var brr = [1,3,[1,5,{x:1,y:1}]];
        //
        //        var arr = [1, 4, 6, 8, "", null, 9, {
        //            x: 1
        //            , y: 2
        //        }, [1, 5, 11, 8, 9, [6, 7, 11], {
        //            q: 1
        //            , a: 2
        //        }]];    
        //        var brr = [1, 2, 5, 8, 9, undefined,"", {
        //            x: 1
        //            , y: 3
        //        }, [1, 5, 6, 8, 9, [6, 111, 11], {
        //            q: 1
        //            , b: 2
        //        }]];
        //
        //        fn(arr, brr);

```